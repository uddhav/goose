// This file is auto-generated by @hey-api/openapi-ts

export type AddSubRecipesRequest = {
    sub_recipes: Array<SubRecipe>;
};

export type AddSubRecipesResponse = {
    success: boolean;
};

export type Annotated = RawTextContent | RawImageContent | RawEmbeddedResource;

export type Annotations = {
    audience?: Array<Role>;
    priority?: number;
    timestamp?: string;
};

export type Author = {
    contact?: string | null;
    metadata?: string | null;
};

export type AuthorRequest = {
    contact?: string | null;
    metadata?: string | null;
};

/**
 * Configuration key metadata for provider setup
 */
export type ConfigKey = {
    /**
     * Optional default value for the key
     */
    default?: string | null;
    /**
     * The name of the configuration key (e.g., "API_KEY")
     */
    name: string;
    /**
     * Whether this key should be configured using OAuth device code flow
     * When true, the provider's configure_oauth() method will be called instead of prompting for manual input
     */
    oauth_flow: boolean;
    /**
     * Whether this key is required for the provider to function
     */
    required: boolean;
    /**
     * Whether this key should be stored securely (e.g., in keychain)
     */
    secret: boolean;
};

export type ConfigKeyQuery = {
    is_secret: boolean;
    key: string;
};

export type ConfigResponse = {
    config: {
        [key: string]: unknown;
    };
};

export type Content = RawTextContent | RawImageContent | RawEmbeddedResource | Annotated;

export type ContextLengthExceeded = {
    msg: string;
};

/**
 * Request payload for context management operations
 */
export type ContextManageRequest = {
    /**
     * Operation to perform: "truncation" or "summarize"
     */
    manageAction: string;
    /**
     * Collection of messages to be managed
     */
    messages: Array<Message>;
};

/**
 * Response from context management operations
 */
export type ContextManageResponse = {
    /**
     * Processed messages after the operation
     */
    messages: Array<Message>;
    /**
     * Token counts for each processed message
     */
    tokenCounts: Array<number>;
};

export type CreateCustomProviderRequest = {
    api_key: string;
    api_url: string;
    display_name: string;
    models: Array<string>;
    provider_type: string;
    supports_streaming?: boolean | null;
};

export type CreateRecipeRequest = {
    activities?: Array<string> | null;
    author?: AuthorRequest | null;
    description: string;
    messages: Array<Message>;
    title: string;
};

export type CreateRecipeResponse = {
    error?: string | null;
    recipe?: Recipe | null;
};

export type CreateScheduleRequest = {
    cron: string;
    execution_mode?: string | null;
    id: string;
    recipe_source: string;
};

export type DecodeRecipeRequest = {
    deeplink: string;
};

export type DecodeRecipeResponse = {
    recipe: Recipe;
};

export type EmbeddedResource = {
    annotations?: Annotations | {
        [key: string]: unknown;
    };
    resource: ResourceContents;
};

export type EncodeRecipeRequest = {
    recipe: Recipe;
};

export type EncodeRecipeResponse = {
    deeplink: string;
};

export type Envs = {
    [key: string]: string;
};

export type ErrorResponse = {
    error: string;
};

export type ExtendPromptRequest = {
    extension: string;
};

export type ExtendPromptResponse = {
    success: boolean;
};

/**
 * Represents the different types of MCP extensions that can be added to the manager
 */
export type ExtensionConfig = {
    available_tools?: Array<string>;
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    description?: string | null;
    env_keys?: Array<string>;
    envs?: Envs;
    /**
     * The name used to identify this extension
     */
    name: string;
    timeout?: number | null;
    type: 'sse';
    uri: string;
} | {
    args: Array<string>;
    available_tools?: Array<string>;
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    cmd: string;
    description?: string | null;
    env_keys?: Array<string>;
    envs?: Envs;
    /**
     * The name used to identify this extension
     */
    name: string;
    timeout?: number | null;
    type: 'stdio';
} | {
    available_tools?: Array<string>;
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    description?: string | null;
    display_name?: string | null;
    /**
     * The name used to identify this extension
     */
    name: string;
    timeout?: number | null;
    type: 'builtin';
} | {
    available_tools?: Array<string>;
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    description?: string | null;
    env_keys?: Array<string>;
    envs?: Envs;
    headers?: {
        [key: string]: string;
    };
    /**
     * The name used to identify this extension
     */
    name: string;
    timeout?: number | null;
    type: 'streamable_http';
    uri: string;
} | {
    available_tools?: Array<string>;
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    /**
     * Instructions for how to use these tools
     */
    instructions?: string | null;
    /**
     * The name used to identify this extension
     */
    name: string;
    /**
     * The tools provided by the frontend
     */
    tools: Array<Tool>;
    type: 'frontend';
} | {
    available_tools?: Array<string>;
    /**
     * The Python code to execute
     */
    code: string;
    /**
     * Python package dependencies required by this extension
     */
    dependencies?: Array<string> | null;
    /**
     * Description of what the extension does
     */
    description?: string | null;
    /**
     * The name used to identify this extension
     */
    name: string;
    /**
     * Timeout in seconds
     */
    timeout?: number | null;
    type: 'inline_python';
};

export type ExtensionEntry = ExtensionConfig & {
    type?: 'ExtensionEntry';
} & {
    enabled: boolean;
};

export type ExtensionQuery = {
    config: ExtensionConfig;
    enabled: boolean;
    name: string;
};

export type ExtensionResponse = {
    extensions: Array<ExtensionEntry>;
};

export type FrontendToolRequest = {
    id: string;
    toolCall: {
        [key: string]: unknown;
    };
};

export type GetToolsQuery = {
    extension_name?: string | null;
};

export type ImageContent = {
    annotations?: Annotations | {
        [key: string]: unknown;
    };
    data: string;
    mimeType: string;
};

export type InspectJobResponse = {
    processStartTime?: string | null;
    runningDurationSeconds?: number | null;
    sessionId?: string | null;
};

export type KillJobResponse = {
    message: string;
};

export type ListSchedulesResponse = {
    jobs: Array<ScheduledJob>;
};

/**
 * A message to or from an LLM
 */
export type Message = {
    content: Array<MessageContent>;
    created?: number;
    id?: string | null;
    role: Role;
};

/**
 * Content passed inside a message, which can be both simple content and tool content
 */
export type MessageContent = (TextContent & {
    type: 'text';
}) | (ImageContent & {
    type: 'image';
}) | (ToolRequest & {
    type: 'toolRequest';
}) | (ToolResponse & {
    type: 'toolResponse';
}) | (ToolConfirmationRequest & {
    type: 'toolConfirmationRequest';
}) | (FrontendToolRequest & {
    type: 'frontendToolRequest';
}) | (ThinkingContent & {
    type: 'thinking';
}) | (RedactedThinkingContent & {
    type: 'redactedThinking';
}) | (ContextLengthExceeded & {
    type: 'contextLengthExceeded';
}) | (SummarizationRequested & {
    type: 'summarizationRequested';
});

/**
 * Information about a model's capabilities
 */
export type ModelInfo = {
    /**
     * The maximum context length this model supports
     */
    context_limit: number;
    /**
     * Currency for the costs (default: "$")
     */
    currency?: string | null;
    /**
     * Cost per token for input (optional)
     */
    input_token_cost?: number | null;
    /**
     * The name of the model
     */
    name: string;
    /**
     * Cost per token for output (optional)
     */
    output_token_cost?: number | null;
    /**
     * Whether this model supports cache control
     */
    supports_cache_control?: boolean | null;
};

export type PermissionConfirmationRequest = {
    action: string;
    id: string;
    principal_type?: PrincipalType;
};

/**
 * Enum representing the possible permission levels for a tool.
 */
export type PermissionLevel = 'always_allow' | 'ask_before' | 'never_allow';

export type PrincipalType = 'Extension' | 'Tool';

export type ProviderDetails = {
    is_configured: boolean;
    metadata: ProviderMetadata;
    name: string;
};

/**
 * Metadata about a provider's configuration requirements and capabilities
 */
export type ProviderMetadata = {
    /**
     * Required configuration keys
     */
    config_keys: Array<ConfigKey>;
    /**
     * The default/recommended model for this provider
     */
    default_model: string;
    /**
     * Description of the provider's capabilities
     */
    description: string;
    /**
     * Display name for the provider in UIs
     */
    display_name: string;
    /**
     * A list of currently known models with their capabilities
     * TODO: eventually query the apis directly
     */
    known_models: Array<ModelInfo>;
    /**
     * Link to the docs where models can be found
     */
    model_doc_link: string;
    /**
     * The unique identifier for this provider
     */
    name: string;
};

export type ProvidersResponse = {
    providers: Array<ProviderDetails>;
};

export type RawEmbeddedResource = {
    resource: ResourceContents;
};

export type RawImageContent = {
    data: string;
    mimeType: string;
};

export type RawTextContent = {
    text: string;
};

/**
 * A Recipe represents a personalized, user-generated agent configuration that defines
 * specific behaviors and capabilities within the Goose system.
 *
 * # Fields
 *
 * ## Required Fields
 * * `version` - Semantic version of the Recipe file format (defaults to "1.0.0")
 * * `title` - Short, descriptive name of the Recipe
 * * `description` - Detailed description explaining the Recipe's purpose and functionality
 * * `Instructions` - Instructions that defines the Recipe's behavior
 *
 * ## Optional Fields
 * * `prompt` - the initial prompt to the session to start with
 * * `extensions` - List of extension configurations required by the Recipe
 * * `context` - Supplementary context information for the Recipe
 * * `activities` - Activity labels that appear when loading the Recipe
 * * `author` - Information about the Recipe's creator and metadata
 * * `parameters` - Additional parameters for the Recipe
 * * `response` - Response configuration including JSON schema validation
 * * `retry` - Retry configuration for automated validation and recovery
 * # Example
 *
 *
 * use goose::recipe::Recipe;
 *
 * // Using the builder pattern
 * let recipe = Recipe::builder()
 * .title("Example Agent")
 * .description("An example Recipe configuration")
 * .instructions("Act as a helpful assistant")
 * .build()
 * .expect("Missing required fields");
 *
 * // Or using struct initialization
 * let recipe = Recipe {
 * version: "1.0.0".to_string(),
 * title: "Example Agent".to_string(),
 * description: "An example Recipe configuration".to_string(),
 * instructions: Some("Act as a helpful assistant".to_string()),
 * prompt: None,
 * extensions: None,
 * context: None,
 * activities: None,
 * author: None,
 * settings: None,
 * parameters: None,
 * response: None,
 * sub_recipes: None,
 * retry: None,
 * };
 *
 */
export type Recipe = {
    activities?: Array<string> | null;
    author?: Author | null;
    context?: Array<string> | null;
    description: string;
    extensions?: Array<ExtensionConfig> | null;
    instructions?: string | null;
    parameters?: Array<RecipeParameter> | null;
    prompt?: string | null;
    response?: Response | null;
    retry?: RetryConfig | null;
    settings?: Settings | null;
    sub_recipes?: Array<SubRecipe> | null;
    title: string;
    version?: string;
};

export type RecipeParameter = {
    default?: string | null;
    description: string;
    input_type: RecipeParameterInputType;
    key: string;
    options?: Array<string> | null;
    requirement: RecipeParameterRequirement;
};

export type RecipeParameterInputType = 'string' | 'number' | 'boolean' | 'date' | 'file' | 'select';

export type RecipeParameterRequirement = 'required' | 'optional' | 'user_prompt';

export type RedactedThinkingContent = {
    data: string;
};

export type ResourceContents = {
    mimeType?: string;
    text: string;
    uri: string;
} | {
    blob: string;
    mimeType?: string;
    uri: string;
};

export type Response = {
    json_schema?: unknown;
};

/**
 * Configuration for retry logic in recipe execution
 */
export type RetryConfig = {
    /**
     * List of success checks to validate recipe completion
     */
    checks: Array<SuccessCheck>;
    /**
     * Maximum number of retry attempts before giving up
     */
    max_retries: number;
    /**
     * Optional shell command to run on failure for cleanup
     */
    on_failure?: string | null;
    /**
     * Timeout in seconds for on_failure commands (default: 600 seconds)
     */
    on_failure_timeout_seconds?: number | null;
    /**
     * Timeout in seconds for individual shell commands (default: 300 seconds)
     */
    timeout_seconds?: number | null;
};

export type Role = string;

export type RunNowResponse = {
    session_id: string;
};

export type ScanRecipeRequest = {
    recipe: Recipe;
};

export type ScanRecipeResponse = {
    has_security_warnings: boolean;
};

export type ScheduledJob = {
    cron: string;
    current_session_id?: string | null;
    currently_running?: boolean;
    execution_mode?: string | null;
    id: string;
    last_run?: string | null;
    paused?: boolean;
    process_start_time?: string | null;
    source: string;
};

export type SessionConfigRequest = {
    response?: Response | null;
};

export type SessionDisplayInfo = {
    accumulatedInputTokens?: number | null;
    accumulatedOutputTokens?: number | null;
    accumulatedTotalTokens?: number | null;
    createdAt: string;
    id: string;
    inputTokens?: number | null;
    messageCount: number;
    name: string;
    outputTokens?: number | null;
    scheduleId?: string | null;
    totalTokens?: number | null;
    workingDir: string;
};

export type SessionHistoryResponse = {
    /**
     * List of messages in the session conversation
     */
    messages: Array<Message>;
    metadata: SessionMetadata;
    /**
     * Unique identifier for the session
     */
    sessionId: string;
};

export type SessionInfo = {
    id: string;
    metadata: SessionMetadata;
    modified: string;
    path: string;
};

export type SessionListResponse = {
    /**
     * List of available session information objects
     */
    sessions: Array<SessionInfo>;
};

/**
 * Metadata for a session, stored as the first line in the session file
 */
export type SessionMetadata = {
    /**
     * The number of input tokens used in the session. Accumulated across all messages.
     */
    accumulated_input_tokens?: number | null;
    /**
     * The number of output tokens used in the session. Accumulated across all messages.
     */
    accumulated_output_tokens?: number | null;
    /**
     * The total number of tokens used in the session. Accumulated across all messages (useful for tracking cost over an entire session).
     */
    accumulated_total_tokens?: number | null;
    /**
     * A short description of the session, typically 3 words or less
     */
    description: string;
    /**
     * The number of input tokens used in the session. Retrieved from the provider's last usage.
     */
    input_tokens?: number | null;
    /**
     * Number of messages in the session
     */
    message_count: number;
    /**
     * The number of output tokens used in the session. Retrieved from the provider's last usage.
     */
    output_tokens?: number | null;
    /**
     * ID of the schedule that triggered this session, if any
     */
    schedule_id?: string | null;
    /**
     * Session-scoped TODO list content
     */
    todo_content?: string | null;
    /**
     * The total number of tokens used in the session. Retrieved from the provider's last usage.
     */
    total_tokens?: number | null;
    /**
     * Working directory for the session
     */
    working_dir: string;
};

export type SessionsQuery = {
    limit?: number;
};

export type Settings = {
    goose_model?: string | null;
    goose_provider?: string | null;
    temperature?: number | null;
};

export type SubRecipe = {
    description?: string | null;
    name: string;
    path: string;
    sequential_when_repeated?: boolean;
    values?: {
        [key: string]: string;
    } | null;
};

/**
 * Execute a shell command and check its exit status
 */
export type SuccessCheck = {
    /**
     * The shell command to execute
     */
    command: string;
    type: 'Shell';
};

export type SummarizationRequested = {
    msg: string;
};

export type TextContent = {
    annotations?: Annotations | {
        [key: string]: unknown;
    };
    text: string;
};

export type ThinkingContent = {
    signature: string;
    thinking: string;
};

export type Tool = {
    annotations?: ToolAnnotations | {
        [key: string]: unknown;
    };
    description?: string;
    inputSchema: {
        [key: string]: unknown;
    };
    name: string;
    outputSchema?: {
        [key: string]: unknown;
    };
};

export type ToolAnnotations = {
    destructiveHint?: boolean;
    idempotentHint?: boolean;
    openWorldHint?: boolean;
    readOnlyHint?: boolean;
    title?: string;
};

export type ToolConfirmationRequest = {
    arguments: unknown;
    id: string;
    prompt?: string | null;
    toolName: string;
};

/**
 * Information about the tool used for building prompts
 */
export type ToolInfo = {
    description: string;
    name: string;
    parameters: Array<string>;
    permission?: PermissionLevel | null;
};

export type ToolPermission = {
    permission: PermissionLevel;
    tool_name: string;
};

export type ToolRequest = {
    id: string;
    toolCall: {
        [key: string]: unknown;
    };
};

export type ToolResponse = {
    id: string;
    toolResult: {
        [key: string]: unknown;
    };
};

export type UpdateProviderRequest = {
    model?: string | null;
    provider: string;
};

export type UpdateScheduleRequest = {
    cron: string;
};

export type UpsertConfigQuery = {
    is_secret: boolean;
    key: string;
    value: unknown;
};

export type UpsertPermissionsQuery = {
    tool_permissions: Array<ToolPermission>;
};

export type AddSubRecipesData = {
    body: AddSubRecipesRequest;
    path?: never;
    query?: never;
    url: '/agent/add_sub_recipes';
};

export type AddSubRecipesErrors = {
    /**
     * Unauthorized - invalid secret key
     */
    401: unknown;
    /**
     * Agent not initialized
     */
    424: unknown;
};

export type AddSubRecipesResponses = {
    /**
     * Added sub recipes to agent successfully
     */
    200: AddSubRecipesResponse;
};

export type AddSubRecipesResponse2 = AddSubRecipesResponses[keyof AddSubRecipesResponses];

export type ExtendPromptData = {
    body: ExtendPromptRequest;
    path?: never;
    query?: never;
    url: '/agent/prompt';
};

export type ExtendPromptErrors = {
    /**
     * Unauthorized - invalid secret key
     */
    401: unknown;
    /**
     * Agent not initialized
     */
    424: unknown;
};

export type ExtendPromptResponses = {
    /**
     * Extended system prompt successfully
     */
    200: ExtendPromptResponse;
};

export type ExtendPromptResponse2 = ExtendPromptResponses[keyof ExtendPromptResponses];

export type UpdateSessionConfigData = {
    body: SessionConfigRequest;
    path?: never;
    query?: never;
    url: '/agent/session_config';
};

export type UpdateSessionConfigErrors = {
    /**
     * Unauthorized - invalid secret key
     */
    401: unknown;
    /**
     * Agent not initialized
     */
    424: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdateSessionConfigResponses = {
    /**
     * Session config updated successfully
     */
    200: string;
};

export type UpdateSessionConfigResponse = UpdateSessionConfigResponses[keyof UpdateSessionConfigResponses];

export type GetToolsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional extension name to filter tools
         */
        extension_name?: string | null;
    };
    url: '/agent/tools';
};

export type GetToolsErrors = {
    /**
     * Unauthorized - invalid secret key
     */
    401: unknown;
    /**
     * Agent not initialized
     */
    424: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetToolsResponses = {
    /**
     * Tools retrieved successfully
     */
    200: Array<ToolInfo>;
};

export type GetToolsResponse = GetToolsResponses[keyof GetToolsResponses];

export type UpdateAgentProviderData = {
    body: UpdateProviderRequest;
    path?: never;
    query?: never;
    url: '/agent/update_provider';
};

export type UpdateAgentProviderErrors = {
    /**
     * Bad request - missing or invalid parameters
     */
    400: unknown;
    /**
     * Unauthorized - invalid secret key
     */
    401: unknown;
    /**
     * Agent not initialized
     */
    424: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdateAgentProviderResponses = {
    /**
     * Provider updated successfully
     */
    200: unknown;
};

export type UpdateRouterToolSelectorData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agent/update_router_tool_selector';
};

export type UpdateRouterToolSelectorErrors = {
    /**
     * Unauthorized - invalid secret key
     */
    401: unknown;
    /**
     * Agent not initialized
     */
    424: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdateRouterToolSelectorResponses = {
    /**
     * Tool selection strategy updated successfully
     */
    200: string;
};

export type UpdateRouterToolSelectorResponse = UpdateRouterToolSelectorResponses[keyof UpdateRouterToolSelectorResponses];

export type ReadAllConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config';
};

export type ReadAllConfigResponses = {
    /**
     * All configuration values retrieved successfully
     */
    200: ConfigResponse;
};

export type ReadAllConfigResponse = ReadAllConfigResponses[keyof ReadAllConfigResponses];

export type BackupConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/backup';
};

export type BackupConfigErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type BackupConfigResponses = {
    /**
     * Config file backed up
     */
    200: string;
};

export type BackupConfigResponse = BackupConfigResponses[keyof BackupConfigResponses];

export type CreateCustomProviderData = {
    body: CreateCustomProviderRequest;
    path?: never;
    query?: never;
    url: '/config/custom-providers';
};

export type CreateCustomProviderErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateCustomProviderResponses = {
    /**
     * Custom provider created successfully
     */
    200: string;
};

export type CreateCustomProviderResponse = CreateCustomProviderResponses[keyof CreateCustomProviderResponses];

export type RemoveCustomProviderData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/config/custom-providers/{id}';
};

export type RemoveCustomProviderErrors = {
    /**
     * Provider not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type RemoveCustomProviderResponses = {
    /**
     * Custom provider removed successfully
     */
    200: string;
};

export type RemoveCustomProviderResponse = RemoveCustomProviderResponses[keyof RemoveCustomProviderResponses];

export type GetExtensionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/extensions';
};

export type GetExtensionsErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetExtensionsResponses = {
    /**
     * All extensions retrieved successfully
     */
    200: ExtensionResponse;
};

export type GetExtensionsResponse = GetExtensionsResponses[keyof GetExtensionsResponses];

export type AddExtensionData = {
    body: ExtensionQuery;
    path?: never;
    query?: never;
    url: '/config/extensions';
};

export type AddExtensionErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Could not serialize config.yaml
     */
    422: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type AddExtensionResponses = {
    /**
     * Extension added or updated successfully
     */
    200: string;
};

export type AddExtensionResponse = AddExtensionResponses[keyof AddExtensionResponses];

export type RemoveExtensionData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/config/extensions/{name}';
};

export type RemoveExtensionErrors = {
    /**
     * Extension not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type RemoveExtensionResponses = {
    /**
     * Extension removed successfully
     */
    200: string;
};

export type RemoveExtensionResponse = RemoveExtensionResponses[keyof RemoveExtensionResponses];

export type InitConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/init';
};

export type InitConfigErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type InitConfigResponses = {
    /**
     * Config initialization check completed
     */
    200: string;
};

export type InitConfigResponse = InitConfigResponses[keyof InitConfigResponses];

export type UpsertPermissionsData = {
    body: UpsertPermissionsQuery;
    path?: never;
    query?: never;
    url: '/config/permissions';
};

export type UpsertPermissionsErrors = {
    /**
     * Invalid request
     */
    400: unknown;
};

export type UpsertPermissionsResponses = {
    /**
     * Permission update completed
     */
    200: string;
};

export type UpsertPermissionsResponse = UpsertPermissionsResponses[keyof UpsertPermissionsResponses];

export type ProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/providers';
};

export type ProvidersResponses = {
    /**
     * All configuration values retrieved successfully
     */
    200: Array<ProviderDetails>;
};

export type ProvidersResponse2 = ProvidersResponses[keyof ProvidersResponses];

export type GetProviderModelsData = {
    body?: never;
    path: {
        /**
         * Provider name (e.g., openai)
         */
        name: string;
    };
    query?: never;
    url: '/config/providers/{name}/models';
};

export type GetProviderModelsErrors = {
    /**
     * Unknown provider, provider not configured, or authentication error
     */
    400: unknown;
    /**
     * Rate limit exceeded
     */
    429: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetProviderModelsResponses = {
    /**
     * Models fetched successfully
     */
    200: Array<string>;
};

export type GetProviderModelsResponse = GetProviderModelsResponses[keyof GetProviderModelsResponses];

export type ReadConfigData = {
    body: ConfigKeyQuery;
    path?: never;
    query?: never;
    url: '/config/read';
};

export type ReadConfigErrors = {
    /**
     * Unable to get the configuration value
     */
    500: unknown;
};

export type ReadConfigResponses = {
    /**
     * Configuration value retrieved successfully
     */
    200: unknown;
};

export type RecoverConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/recover';
};

export type RecoverConfigErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type RecoverConfigResponses = {
    /**
     * Config recovery attempted
     */
    200: string;
};

export type RecoverConfigResponse = RecoverConfigResponses[keyof RecoverConfigResponses];

export type RemoveConfigData = {
    body: ConfigKeyQuery;
    path?: never;
    query?: never;
    url: '/config/remove';
};

export type RemoveConfigErrors = {
    /**
     * Configuration key not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type RemoveConfigResponses = {
    /**
     * Configuration value removed successfully
     */
    200: string;
};

export type RemoveConfigResponse = RemoveConfigResponses[keyof RemoveConfigResponses];

export type UpsertConfigData = {
    body: UpsertConfigQuery;
    path?: never;
    query?: never;
    url: '/config/upsert';
};

export type UpsertConfigErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpsertConfigResponses = {
    /**
     * Configuration value upserted successfully
     */
    200: string;
};

export type UpsertConfigResponse = UpsertConfigResponses[keyof UpsertConfigResponses];

export type ValidateConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/validate';
};

export type ValidateConfigErrors = {
    /**
     * Config file is corrupted
     */
    422: unknown;
};

export type ValidateConfigResponses = {
    /**
     * Config validation result
     */
    200: string;
};

export type ValidateConfigResponse = ValidateConfigResponses[keyof ValidateConfigResponses];

export type ConfirmPermissionData = {
    body: PermissionConfirmationRequest;
    path?: never;
    query?: never;
    url: '/confirm';
};

export type ConfirmPermissionErrors = {
    /**
     * Unauthorized - invalid secret key
     */
    401: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ConfirmPermissionResponses = {
    /**
     * Permission action is confirmed
     */
    200: unknown;
};

export type ManageContextData = {
    body: ContextManageRequest;
    path?: never;
    query?: never;
    url: '/context/manage';
};

export type ManageContextErrors = {
    /**
     * Unauthorized - Invalid or missing API key
     */
    401: unknown;
    /**
     * Precondition failed - Agent not available
     */
    412: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ManageContextResponses = {
    /**
     * Context managed successfully
     */
    200: ContextManageResponse;
};

export type ManageContextResponse = ManageContextResponses[keyof ManageContextResponses];

export type CreateRecipeData = {
    body: CreateRecipeRequest;
    path?: never;
    query?: never;
    url: '/recipes/create';
};

export type CreateRecipeErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Precondition failed - Agent not available
     */
    412: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateRecipeResponses = {
    /**
     * Recipe created successfully
     */
    200: CreateRecipeResponse;
};

export type CreateRecipeResponse2 = CreateRecipeResponses[keyof CreateRecipeResponses];

export type DecodeRecipeData = {
    body: DecodeRecipeRequest;
    path?: never;
    query?: never;
    url: '/recipes/decode';
};

export type DecodeRecipeErrors = {
    /**
     * Bad request
     */
    400: unknown;
};

export type DecodeRecipeResponses = {
    /**
     * Recipe decoded successfully
     */
    200: DecodeRecipeResponse;
};

export type DecodeRecipeResponse2 = DecodeRecipeResponses[keyof DecodeRecipeResponses];

export type EncodeRecipeData = {
    body: EncodeRecipeRequest;
    path?: never;
    query?: never;
    url: '/recipes/encode';
};

export type EncodeRecipeErrors = {
    /**
     * Bad request
     */
    400: unknown;
};

export type EncodeRecipeResponses = {
    /**
     * Recipe encoded successfully
     */
    200: EncodeRecipeResponse;
};

export type EncodeRecipeResponse2 = EncodeRecipeResponses[keyof EncodeRecipeResponses];

export type ScanRecipeData = {
    body: ScanRecipeRequest;
    path?: never;
    query?: never;
    url: '/recipes/scan';
};

export type ScanRecipeResponses = {
    /**
     * Recipe scanned successfully
     */
    200: ScanRecipeResponse;
};

export type ScanRecipeResponse2 = ScanRecipeResponses[keyof ScanRecipeResponses];

export type CreateScheduleData = {
    body: CreateScheduleRequest;
    path?: never;
    query?: never;
    url: '/schedule/create';
};

export type CreateScheduleErrors = {
    /**
     * Invalid cron expression or recipe file
     */
    400: unknown;
    /**
     * Job ID already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateScheduleResponses = {
    /**
     * Scheduled job created successfully
     */
    200: ScheduledJob;
};

export type CreateScheduleResponse = CreateScheduleResponses[keyof CreateScheduleResponses];

export type DeleteScheduleData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to delete
         */
        id: string;
    };
    query?: never;
    url: '/schedule/delete/{id}';
};

export type DeleteScheduleErrors = {
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeleteScheduleResponses = {
    /**
     * Scheduled job deleted successfully
     */
    204: void;
};

export type DeleteScheduleResponse = DeleteScheduleResponses[keyof DeleteScheduleResponses];

export type ListSchedulesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/schedule/list';
};

export type ListSchedulesErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListSchedulesResponses = {
    /**
     * A list of scheduled jobs
     */
    200: ListSchedulesResponse;
};

export type ListSchedulesResponse2 = ListSchedulesResponses[keyof ListSchedulesResponses];

export type UpdateScheduleData = {
    body: UpdateScheduleRequest;
    path: {
        /**
         * ID of the schedule to update
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}';
};

export type UpdateScheduleErrors = {
    /**
     * Cannot update a currently running job or invalid request
     */
    400: unknown;
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdateScheduleResponses = {
    /**
     * Scheduled job updated successfully
     */
    200: ScheduledJob;
};

export type UpdateScheduleResponse = UpdateScheduleResponses[keyof UpdateScheduleResponses];

export type InspectRunningJobData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to inspect
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/inspect';
};

export type InspectRunningJobErrors = {
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type InspectRunningJobResponses = {
    /**
     * Running job information
     */
    200: InspectJobResponse;
};

export type InspectRunningJobResponse = InspectRunningJobResponses[keyof InspectRunningJobResponses];

export type KillRunningJobData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/kill';
};

export type KillRunningJobResponses = {
    /**
     * Running job killed successfully
     */
    200: unknown;
};

export type PauseScheduleData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to pause
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/pause';
};

export type PauseScheduleErrors = {
    /**
     * Cannot pause a currently running job
     */
    400: unknown;
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type PauseScheduleResponses = {
    /**
     * Scheduled job paused successfully
     */
    204: void;
};

export type PauseScheduleResponse = PauseScheduleResponses[keyof PauseScheduleResponses];

export type RunNowHandlerData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to run
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/run_now';
};

export type RunNowHandlerErrors = {
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error when trying to run the job
     */
    500: unknown;
};

export type RunNowHandlerResponses = {
    /**
     * Scheduled job triggered successfully, returns new session ID
     */
    200: RunNowResponse;
};

export type RunNowHandlerResponse = RunNowHandlerResponses[keyof RunNowHandlerResponses];

export type SessionsHandlerData = {
    body?: never;
    path: {
        /**
         * ID of the schedule
         */
        id: string;
    };
    query?: {
        limit?: number;
    };
    url: '/schedule/{id}/sessions';
};

export type SessionsHandlerErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type SessionsHandlerResponses = {
    /**
     * A list of session display info
     */
    200: Array<SessionDisplayInfo>;
};

export type SessionsHandlerResponse = SessionsHandlerResponses[keyof SessionsHandlerResponses];

export type UnpauseScheduleData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to unpause
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/unpause';
};

export type UnpauseScheduleErrors = {
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UnpauseScheduleResponses = {
    /**
     * Scheduled job unpaused successfully
     */
    204: void;
};

export type UnpauseScheduleResponse = UnpauseScheduleResponses[keyof UnpauseScheduleResponses];

export type ListSessionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sessions';
};

export type ListSessionsErrors = {
    /**
     * Unauthorized - Invalid or missing API key
     */
    401: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListSessionsResponses = {
    /**
     * List of available sessions retrieved successfully
     */
    200: SessionListResponse;
};

export type ListSessionsResponse = ListSessionsResponses[keyof ListSessionsResponses];

export type GetSessionHistoryData = {
    body?: never;
    path: {
        /**
         * Unique identifier for the session
         */
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}';
};

export type GetSessionHistoryErrors = {
    /**
     * Unauthorized - Invalid or missing API key
     */
    401: unknown;
    /**
     * Session not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetSessionHistoryResponses = {
    /**
     * Session history retrieved successfully
     */
    200: SessionHistoryResponse;
};

export type GetSessionHistoryResponse = GetSessionHistoryResponses[keyof GetSessionHistoryResponses];

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};